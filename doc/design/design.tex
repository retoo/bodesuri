\documentclass[12pt,halfparskip]{scrartcl}

\newcommand{\dokumenttitel}{Design}
\usepackage{../bodesuri}


\begin{document}

\input{../titelseite}

\section{Systemstruktur} % (fold)
\label{Systemstruktur}

\subsection{Architektur√ºbersicht} % (fold)
\label{sub:architekturuebersicht}

Bodesuri ist √ºber mehrere Rechner verteilt. Es gibt vier Clients und einen Server pro Spiel. Der Client und der Server sind getrennte Programme, welche aber eine gemeinsame Codebasis haben.

Die Grundbausteine der Kommunikation zwischen Client und Server sind Zug und Zuginformation. Der Server sendet dem Spieler, der am Zug ist, eine Zugaufforderung. Auf die antwortet der Spieler mit einem Zug, welcher den Spieler, die gezogene Karte und die Bewegung der Figuren enth√§lt. Der Server verteilt dann diese Informationen als Zuginformation an alle Spieler, wie man in Abbildung~\vref{fig:client_server} sehen kann.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7 \textwidth]{client_server}
	\caption{Kommunikation zwischen Client \& Server}
	\label{fig:client_server}
\end{figure}

Die Validierung der gespielten Z√ºge geschieht beim Client, der Server ist zust√§ndig f√ºr den Spielablauf.

\subsection{Architektonische Ziele \& Einschr√§nkungen} % (fold)
\label{sub:architektonische_ziele_einschraenkungen}
\paragraph{Designentscheidungen}\label{ssub:designentscheidungen} % (fold)
\subparagraph{Zustandsautomat} % (fold)
\label{ssub:zustandsautomat}
\subparagraph{Layers} % (fold)
\label{ssub:layers}

% subparagraph layers (end)

% subparagraph zustandsautomat (end)
\paragraph{Multitier Architektur des Servers}\label{ssub:multitier_architektur_des_servers} % (fold)
Der Server wurde in mehrere Schichten und vertikal angeordnete Partitions aufgeteilt. Diese Hierarchie hat sich deshalb als erforderlich erwiesen, da sonst Abh√§ngigkeiten von tieferliegenden zu h√∂herliegenden Schichten entstehen w√ºrden.
% paragraph multitier_architektur_des_servers (end)
\paragraph{Applikationsschicht}\label{ssub:applikationsschicht} % (fold)
Die Applikationsschicht wurde eingef√ºhrt, weil es wegen der Netzwerkf√§higkeit viel Synchronisationsarbeit (z.\,B. f√ºr Zust√§nde) gibt. Sie hat folgende Hauptaufgaben:
	\begin{itemize}
		\item Zustandssynchronisation als erste Vorstufe der Netzwerkkommunikation. Spezifische Nachrichten werden eingepackt, an die darunterliegenden Schichten weitergeleitet, um dann √ºber das Netzwerk verteilt und empfangen zu werden.
		\item Controller-Komponente des MVC-Konzeptes, welche die Ereignisse im UI abf√§ngt und verarbeitet, sowie √Ñnderungen in der Problem Domain an das UI weiterleitet.
	\end{itemize}
% paragraph applikationsschicht (end)
% paragraph designentscheidungen (end)
\paragraph{Verwendete Entwicklungswerkzeuge}\label{ssub:verwendete_entwicklungswerkzeuge} % (fold)
Als Entwicklungswerkzeug wird MagicDraw UML verwendet. Es arbeitet Plattformunabh√§ngig (Java), ist einfach handhabbar und hat sehr gute Funktionalit√§ten zur Code-Generierung. Die erzeugten Dateien lassen sich im XML-Format im SVN-Repository verwalten. Ein Nachteil ist, dass immer nur eine Person gleichzeitig an einem Projekt/Modul arbeiten kann, da MagicDraw UML keine SVN-Integration bietet und Konflikte nicht aufgel√∂st werden k√∂nnen.
% paragraph verwendete_entwicklungswerkzeuge (end)
\paragraph{Teamstruktur}\label{ssub:teamstruktur} % (fold)
Die Aufteilung des Teams ist aus den Arbeitspaketen in der Excel-Zeiterfassung ersichtlich. Die Verantwortlichkeiten sind in der Analysespezifikation geregelt.
% paragraph teamstruktur (end)
% subsection architektonische_ziele_einschraenkungen (end)

\clearpage
\section{Design Pakete} % (fold)
\label{design_pakete}

\subsection{Logische Sicht} % (fold)
\label{sub:logische_sicht}

Die logische Sicht beschreibt die Unterteilung der Architektur in die Schichten, Tiers, Packages und Klassen. Abbildung~\vref{fig:legende_diagramme} zeigt die Legende f√ºr die daf√ºr verwendeten Klassendiagramme.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{legende_diagramme}
	\caption{Legende der Diagrammfarben}
	\label{fig:legende_diagramme}
\end{figure}

\subsubsection{Schichtenarchitektur} % (fold)
\label{sub:schichtenarchitektur}
F√ºr die logische Strukturierung des Projektes wird eine vierschichtige Architektur verwendet, wie in Abbildung~\vref{fig:architektur_schichten} dargestellt. Dabei setzt jede Schicht direkt auf den Diensten der darunterliegenden Schichten auf. Schichten k√∂nnen transparent sein. Dadurch ergeben sich wenige Indirektionen und eine einfache Nutzung der Dienste einer Schicht. Wo m√∂glich und sinnvoll, werden Schnittstellen zwischen Schichten durch eine Fassade geb√ºndelt, um die Kopplung zwischen den Schichten zu verringern. Dadurch lassen sich die Schnittstellen f√ºr die Schichten auch klarer definieren und sind einfacher zu nutzen. Im UI wird das MVC-Konzept verwendet, da eine komplexe Darstellungslogik durch das Spiel gegeben ist.
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{architektur_schichten}
	\caption{Schichtenarchitektur}
	\label{fig:architektur_schichten}
\end{figure}
% subsubsection schichtenarchitektur (end)

\clearpage

\subsubsection{Package pd} % (fold)
\label{ssub:package_pd}
\subparagraph{Beschreibung}
In der Problem-Domain-Schicht wird die gesamte Spiellogik gekapselt. Sie wird direkt von der dar√ºberliegenden Applikationsschicht verwendet.

\subparagraph{Schnittstellen} % (fold)
\label{ssub:schnittstellen}
\begin{itemize}
	\item Package pd.zugsystem wird von applikation.zugentgegennahme verwendet, um Z√ºge zu verarbeiten.
\end{itemize}
% subparagraph schnittstellen (end)
% subsubsection package_pd (end)

\clearpage
\subsubsection{Package pd.karten} % (fold)
\label{ssub:package_pd_karten}
\subparagraph{Beschreibung}
Beinhaltet alle Karten, die Kartenfarben, das Deck und den Kartengeber.

\subparagraph{Schnittstellen} % (fold)
\label{ssub:schnittstellen}
\begin{itemize}
	\item Als Einstiegspunkt f√ºr die Karten wird der Kartengeber verwendet, welcher das Mischen und das Ziehen einer Karte vom Stapel bereitstellt.
\end{itemize}
% subparagraph schnittstellen (end)

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_kartengeber}
	\caption{Kartengeber}
	\label{fig:pd_kartengeber}
\end{figure}

% subsubsection package_pd_karten (end)

\clearpage
\subsubsection{Package pd.regelsystem, pd.zugsystem} % (fold)
\label{ssub:package_pd_regelsystem}
\subparagraph{Beschreibung}
Das Regel- und das Zugsystem sind eng miteinander verbunden. Sie nehmen die Aufgaben der Problem-Domain-Schicht wahr und stellen die Validierung der Z√ºge sicher und berechnet die daraus resultierenden Aktionen in der Problem Domain (Figur von Feld X auf Feld Y verschieben).

\subparagraph{Schnittstellen} % (fold)
\label{ssub:schnittstellen}
\begin{itemize}
	\item Die Zugeingabe fasst die Informationen zusammen, die f√ºr einen Zug ben√∂tigt werden und √ºber sie wird validiert, was zu einem ausf√ºhrbaren Zug f√ºhrt.
\end{itemize}
% subparagraph schnittstellen (end)

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_regelsystem}
	\caption{Regelsystem}
	\label{fig:pd_regelsystem}
\end{figure}

% paragraph package_pd_regelsystem (end)

\clearpage
\subsubsection{Package pd.brett, pd.spieler} % (fold)
\label{ssub:package_pd_brett}
\subparagraph{Beschreibung}
Die beiden Packages sind eng miteinander verbunden und stellen die Abstraktion des Bretts (welches die Felder enth√§lt), der Figuren und des Spielers in der Problem Domain dar.

\subparagraph{Schnittstellen}
\begin{itemize}
	\item Der Einstiegspunkt ist das Spiel, da es das Brett, den Kartengeber und die Spieler enth√§lt.
\end{itemize}

\label{ssub:diagramme}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_brett}
	\caption{Brett und Figuren}
	\label{fig:pd_brett}
\end{figure}

% paragraph package_pd_brett (end)

\clearpage
\subsubsection{Package pd.serialisierung}

\subparagraph{Beschreibung}
Implementiert die abstrakten Klassen von dienste.serialisierung, um die Serialisierung von Klassen der Problem Domain zu erm√∂glichen.

\subparagraph{Schnittstellen}
\begin{itemize}
	\item Bietet eine Basisklasse (BodesuriCodierbaresObjekt) f√ºr die Klassen der Problem Domain an, die serialisiert werden k√∂nnen.
\end{itemize}

\clearpage
\subsubsection{Package dienste.automat} % (fold)
\label{ssub:package_dienste}
\subparagraph{Beschreibung}
Beinhaltet einen Zustandsautomaten der im Client und im Server eine gezielte Abarbeitung
des Spielablaufs sorgt. Der Automat wechselt aufgrund externer Events auf vorher definierten
Bahnen zwischen den Zust√§nden hin und her.

\subparagraph{Schnittstellen} % (fold)
\label{ssub:schnittstellen}
\begin{itemize}
	\item Der Automat muss von den dar√ºberliegenden Klassen abgeleitet und spezifisch implementiert werden.
\end{itemize}	
% subparagraph schnittstellen (end)

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_automat_klassendiagramm}
	\caption{Automat Klassendiagramm}
	\label{fig:dienste_serialisierung}
\end{figure}

% paragraph package_automat (end)

\clearpage
\subsubsection{Package dienste.serialisierung} % (fold)
\label{ssub:package_dienste_serialisierung}
\subparagraph{Beschreibung}
Dieses Package ist f√ºr die Serialisierung und Deserialisierung der Java-Objekte zust√§ndig, welche anschliessend √ºber das Netzwerk versendet werden.

\subparagraph{Schnittstellen} % (fold)
\label{ssub:schnittstellen}
Um die Serialisierung zu Nutzen, m√ºssen die beiden abstrakten Klassen CodierbaresObjekt und CodiertesObjekt implementiert werden. In beiden muss die Methode getCodierer() implementiert werden, die eine Instanz des verwendeten Codierers zur√ºckgibt. In CodierbaresObjekt muss zus√§tzlich noch die Methode getCodiertesObjekt(String code) implementiert werden, die ein neues konkretes CodiertesObjekt (z.\,B. BodesuriCodiertesObjekt) erstellen sollte.
% subparagraph schnittstellen (end)
% paragraph package_dienste_serialisierung (end)

\clearpage
\subsubsection{Package dienste.netzwerk} % (fold)
\label{ssub:package_dienste_netzwerk}
\subparagraph{Beschreibung}
Dieses Package kapselt die Socket-Schnittstelle von Java und bietet Dienste f√ºr die Netzwerkkommunikation an.

\subparagraph{Schnittstellen} % (fold)
\label{ssub:schnittstellen}
\begin{itemize}
	\item dienste.netzwerk verwendet die Klassen Event und EventQueue f√ºr die Kommunikation mit den dar√ºberliegenden Schichten.
	\item Die Kommunikation mit dem Netzewrk findet √ºber die Bibliotheken java.net statt.
\end{itemize}
% subparagraph schnittstellen (end)
% paragraph package_dienste_netzwerk (end)

\clearpage
\subsubsection{Package ui} % (fold)
\label{ssub:package_ui}
Die UI-Schicht ist f√ºr die graphische Darstellung verantwortlich. Sie kommuniziert mit der Applikationsschicht top-down √ºber direkte Assoziationen und bottom-up √ºber Observer.
% subparagraph beschreibung (end)
% paragraph package_ui (end)

\begin{description}
	\item[ui.lobby] Ist f¸r die Darstellung der Lobby verantwortlich.
	\item[ui.ressourcen] Es beinhaltet die Resourcen, die f¸r das Optische benˆtigt wird.
	\item[ui.spiel] Wird verwendet um die Views des Spieles zusammen zu f¸hren.
	\item[ui.spiel.brett] K¸mmert sich um die Darstellung des Brettes.
	\item[ui.spiel.chat] Dient zur Kommunikation f¸r die einzelnen Spieler untereinander.
	\item[ui.spiel.info] Stellt das View dar, das die Spielerinfos beinhalett.
	\item[ui.verbinden] Dient zur Herstellung der Verbindung mit dem Server.
\end{description}

\clearpage
\subsubsection{Package applikation} % (fold)
\label{ssub:package_applikation}
\subparagraph{Beschreibung}
Die Applikationsschicht ist f√ºr die Zustandsynchronisation (Spielst√§nde usw.) verantwortlich. 

\subparagraph{Schnittstellen} % (fold)
\label{ssub:schnittstellen}
Beschreibung der Schnittstellen
% subparagraph schnittstellen (end)
% paragraph package_applikation (end)

\clearpage
\subsubsection{Package applikation.zugentgegennahme} % (fold)
\label{ssub:package_applikation_zugentgegennahme}
\subparagraph{Beschreibung}
Beschreibung des Package. Aufgabe, etc‚Ä¶

\subparagraph{Schnittstellen} % (fold)
\label{ssub:schnittstellen}
Beschreibung der Schnittstellen
% subparagraph schnittstellen (end)
% paragraph package_applikation_zugentgegennahme (end)

\clearpage
\subsubsection{Package applikation.zustandsynchronisation} % (fold)
\label{ssub:package_app_zustandsynchronisation}
\subparagraph{Beschreibung}
Beschreibung des Package. Aufgabe, etc‚Ä¶

\subparagraph{Schnittstellen} % (fold)
\label{ssub:schnittstellen}
Beschreibung der Schnittstellen
% subparagraph schnittstellen (end)
% paragraph package_app_zustandsynchronisation (end)

% subsubsection design_pakete (end)
% subsection logische_architektur (end)

\clearpage
\subsection{Physikalische Sicht}

\subsubsection{Prozesse \& Threads} % (fold)
\label{sub:prozesse_threads}
Beschrieben, wie diese ablaufen, miteinander funktionieren, Daten austauschen, sich synchronisieren, etc...
% subsection prozesse_threads (end)


\clearpage
\section{Spielzust√§nde \& Nachrichten} % (fold)
\label{spielzustaende_nachrichten}

\clearpage
\section{Dynamische Abl√§ufe} % (fold)
\label{dynamische_ablauefe}
\subsection{Validierung von Spielz√ºgen} % (fold)
\label{ssub:validierung_von_spielz√ºgen}
Abbildung~\vref{fig:pd_validierung} zeigt die Validierung der Spielz√ºge.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_validierung}
	\caption{Validierung von Spielz√ºgen}
	\label{fig:pd_validierung}
\end{figure}
% subsection validierung_von_spielz√ºgen (end)

\subsection{Serialiserung} % (fold)
\label{sub:serialiserung}
Abbildung~\vref{fig:dienste_serialisierung} zeigt der Ablauf bei der Serialisierung von Objekten, damit sie √ºber das Netzwerk √ºbertragen werden k√∂nnen. \textbf{FIXME: 1. Linie -> Erstellen eines serialisierbaren Objektes.}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_serialisierung}
	\caption{Serialisierung}
	\label{fig:dienste_serialisierung}
\end{figure}
% subsection serialiserung (end)

\subsection{Partnerschaften bilden} % (fold)
\label{sub:partnerschaften_bilden}
Abbildung~\vref{fig:dienste_partner} zeigt die m√∂glichen Zust√§nde beim Finden eines Partners.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_partner}
	\caption{Partner Verhalten}
	\label{fig:dienste_partner}
\end{figure}

Die Abildungen~\vref{fig:dienste_partnerschaft_normal_1} und~\vref{fig:dienste_partnerschaft_normal_2} zeigen Ablauf des bildens von Partnerschaften.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_partnerschaft_normal_1}
	\caption{Normale Partnerschaft - Teil 1 von 2}
	\label{fig:dienste_partnerschaft_normal_1}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_partnerschaft_normal_2}
	\caption{Normale Partnerschaft - Teil 2 von 2}
	\label{fig:dienste_partnerschaft_normal_2}
\end{figure}
% subsection partnerschaften_bilden (end)

\subsection{Rundenstart} % (fold)
\label{sub:rundenstart}
Die Abbildung~\vref{fig:dienste_rundenstart} zeigt den Ablauf beim Start einer neuen Runde.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_rundenstart}
	\caption{Rundenstart}
	\label{fig:dienste_rundenstart}
\end{figure}
% subsection rundenstart (end)

\subsection{Zust√§nde des Client} % (fold)
\label{sub:zust√§nde_des_client}
Abbildung~\vref{fig:dienste_client} zeigt alle m√∂glichen Zust√§nde des Clients.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8 \textwidth]{dienste_client}
	\caption{Zust√§nde des Client}
	\label{fig:dienste_client}
\end{figure}
% subsection zust√§nde_des_client (end)

\subsection{Nachrichtenaustausch zwischen Client und Server} % (fold)
\label{sub:nachrichtenaustausch_zwischen_client_und_server}
Abbildung~\vref{fig:dienste_chat} zeigt den Verlauf des Nachrichtenaustauschen zwischen den Clients und dem Server am Beispiel einer Chat-Nachricht.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_chat}
	\caption{Chat Subsystem}
	\label{fig:dienste_chat}
\end{figure}
% subsection nachrichtenaustausch_zwischen_client_und_server (end)
\clearpage

\section{Externes Design} % (fold)
\label{externes_design}

\subsection{Verbindung zum Server} % (fold)
\label{externes_design_verbindung}

Beim Starten des Spiels wird der Spieler aufgefordert, die Serverdaten zur Verbindung eizugeben, sowie seinen Spielernamen.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7 \textwidth]{gui_verbindung}
	\caption{Verbindung zum Server}
	\label{fig:gui_verbindung}
\end{figure}

\clearpage

\subsection{Lobby} % (fold)
\label{externes_design_lobby}

In der Lobby k√∂nnen die Spieler einen Partner f√ºr das Spiel ausw√§hlen. Man w√§hlt den Partner aus und gibt einen Gruppennamen ein. Nun muss nur noch der ausgew√§hlte Partner die Anfrage akzeptieren, um die Gruppe zu bilden. Sobald der Spieler bereit ist, dem Spiel beizutreten w√§hlt er im Spielstatus das H√§kchen "<bereit"> aus. In der Zwischenzeit k√∂nnen sich die Spieler im Chat unterhalten (Priorit√§t 3).

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{gui_lobby}
	\caption{Lobby vor dem Spielbeginn}
	\label{fig:gui_lobby}
\end{figure}

\clearpage

\subsection{Spiel} % (fold)
\label{externes_design_spielbrett}

Das Spiel besteht aus verschiedenen Views. In der BrettView wird das Spielbrett mit den Feldern und Spielfiguren dargestellt. In der SpielerView werden die einzelnen Spieler mit Gruppenzugeh√∂rigkeit aufgelistet. Die KartenView beinhaltet die Karten des Spielers. In der ChatView k√∂nnen sich die Spieler unterhalten (Priorit√§t 3).

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{gui_spiel}
	\caption{Spielbrett}
	\label{fig:gui_spiel}
\end{figure}

% subsection externes_design (end)

\clearpage
\section{Eingetretene Risiken} % (fold)
\label{eingetretene_risiken}

\subsection{RMI} % (fold)
\label{sub:rmi}

Im Verlauf der ersten Tests mit RMI stellte sich schnell heraus, dass RMI weit mehr kann als f√ºr das Projekt notwendig w√§re und es dem Projekt somit unn√∂tig Komplexit√§t hinzuf√ºgt. Andererseits stellt RMI  einige Anforderungen an die Client/Server-Struktur, die sich nur schwer mit den Projektanforderungen decken lassen. So kann RMI nur erschwert hinter Firewalls betrieben werden und eine Kommunikation √ºber ein durch NAT\footnote{Network Adress Translation. Firewall-Feature welches Netzbereiche auf andere Netzbereiche abbildet. Wird h√§ufig verwendet, um private Adressbereiche im Internet hinter einer einzelnen Adresse zu verstecken.} verstecktes Netzwerk ist gar nicht erst m√∂glich. Da die Internet-Zugangsl√∂sungen in den meisten Haushalten auf Firewalls und NAT basieren, k√∂nnte das Spiel von einem gr√∂sseren Teil der potenziellen Kundschaft gar nicht gespielt werden.

Wir entschieden uns auf Grund dieser Probleme, auf eine eigene L√∂sung umzusteigen, welche auf den Java-Klassen Socket und Object(Input|Output)Stream basiert. Insgesamt gingen etwa 10 Stunden Arbeit f√ºr diese Umstellung verloren.
% subsection rmi (end)

\subsection{Java 2D} % (fold)
\label{java_2d}

Nachdem das CLI (Command Line Interface) erstellt war, entwarfen wir ein GUI daf√ºr, das die Felder und Figuren darstellen sollte. Mit Java 2D ist das Zeichnen sehr einfach, da man die Koordinaten der zu zeichnenden Elemente angeben kann. Doch mussten wir leider feststellen, dass das Ansprechen eines Objektes etwas komplizierter ist. So muss zum Beispiel bei einem Mausklick das geklickte Objekt √ºber die Koordinaten ermittelt werden. Ausserdem muss man sich um das Aktualisieren der Anzeige bei Ver√§nderungen selber k√ºmmern.

In einem zweiten Versuch erstellten wir das selbe Spielbrett mit Swing und wir kamen zum Schluss, dass dies die einfachere Methode ist. Die Objekte k√∂nnen mit einem speziellen Layout auch auf Koordinaten genau platziert werden und Klicke darauf kann man wie gewohnt mit einem MouseListener abfangen. Als Objekt kann man zum Beispiel ein Label mit einem Icon verwenden. Dies reicht f√ºr ein Brettspiel vollkommen aus.

Aus diesen Gr√ºnden haben wir uns dazu entschlossen, f√ºr das GUI als einzige Technologie Swing einzusetzen. Insgesamt gingen 7.5 Stunden Arbeit f√ºr diese Umstellung verloren.

% subsection java_2d (end)

% section eingetretene_risiken (end)

\end{document}
