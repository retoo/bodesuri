\documentclass[12pt,halfparskip]{scrartcl}

\newcommand{\dokumenttitel}{Design}
\usepackage{../bodesuri}


\begin{document}

\input{../titelseite}

\section{Architektur√ºbersicht}

Bodesuri ist √ºber mehrere Rechner verteilt. Es gibt vier Clients und einen Server pro Spiel. Der Client und der Server sind getrennte Programme, welche aber eine gemeinsame Codebasis haben.

Zwischen Client und Server werden Nachrichten verschiedener Typen zur Synchronisation ausgetauscht. Ein Beispiel anhand der Z√ºge: Der Server sendet dem Spieler, der am Zug ist, eine Zugaufforderung. Auf die antwortet der Spieler mit einem Zug, welcher den Spieler, die gezogene Karte und die Bewegung der Figuren enth√§lt. Der Server verteilt dann diese Informationen als Zuginformation an alle Spieler, wie man in Abbildung~\vref{fig:client_server} sehen kann.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6 \textwidth]{client_server}
	\caption{Kommunikation zwischen Client \& Server}
	\label{fig:client_server}
\end{figure}

Die Validierung der gespielten Z√ºge geschieht sowohl auf dem Client als auch auf dem Server. Der Server ist ausserdem noch zust√§ndig f√ºr die Koordination des Spielablaufs und f√ºr die Kommunikation zwischen den Spielern.

\clearpage
\section{Design Pakete}
\label{design_pakete}

\subsection{Logische Sicht}
\label{sub:logische_sicht}

\subsubsection{Schichtenarchitektur}
\label{sub:schichtenarchitektur}
F√ºr die logische Strukturierung des Projektes wird eine vierschichtige Architektur verwendet, wie in Abbildung~\vref{fig:architektur_schichten} dargestellt. Dabei setzt jede Schicht direkt auf den Diensten der darunterliegenden Schichten auf. Schichten k√∂nnen transparent sein. Dadurch ergeben sich wenige Indirektionen und eine einfache Nutzung der Dienste einer Schicht. Wo m√∂glich und sinnvoll, werden Schnittstellen zwischen Schichten durch eine Fassade geb√ºndelt, um die Kopplung zwischen den Schichten zu verringern. Dadurch lassen sich die Schnittstellen f√ºr die Schichten auch klarer definieren und sind einfacher zu nutzen. Im UI wird das MVC-Konzept verwendet, da eine komplexe Darstellungslogik durch das Spiel gegeben ist.
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{architektur_schichten}
	\caption{Schichtenarchitektur}
	\label{fig:architektur_schichten}
\end{figure}
\clearpage
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{architektur_partitions}
	\caption{Partitionen in der Architektur}
	\label{fig:architektur_partitions}
\end{figure}

\clearpage

\subsubsection{Package pd}
\label{ssub:package_pd}
\subparagraph{Beschreibung}
In der Problem-Domain-Schicht wird die gesamte Spiellogik gekapselt. Sie wird direkt von der dar√ºberliegenden Applikationsschicht verwendet.

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Package pd.zugsystem wird von applikation.zugentgegennahme verwendet, um Z√ºge zu verarbeiten.
\end{itemize}

\subsubsection{Package pd.karten}
\label{ssub:package_pd_karten}
\subparagraph{Beschreibung}
Beinhaltet alle Karten, die Kartenfarben, das Deck und den Kartengeber. 

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Als Einstiegspunkt f√ºr die Karten wird der Kartengeber verwendet, welcher das Mischen und das Ziehen einer Karte vom Stapel bereitstellt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8 \textwidth]{pd_kartengeber}
	\caption{Klassendiagramm Kartengeber}
	\label{fig:pd_kartengeber}
\end{figure}

\clearpage
\subsubsection{Package pd.regelsystem, pd.zugsystem}
\label{ssub:package_pd_regelsystem}
\subparagraph{Beschreibung}
Das Regel- und das Zugsystem sind eng miteinander verbunden. Sie nehmen die Aufgaben der Problem-Domain-Schicht wahr und stellen die Validierung der Z√ºge sicher und berechnen die daraus resultierenden Aktionen in der Problem-Domain (Figur von Feld X auf Feld Y verschieben).

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Die Zugeingabe fasst die Informationen zusammen, die f√ºr einen Zug ben√∂tigt werden und √ºber sie wird validiert, was zu einem ausf√ºhrbaren Zug f√ºhrt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_regelsystem}
	\caption{Klassendiagramm Regelsystem}
	\label{fig:pd_regelsystem}
\end{figure}

\clearpage
\subsubsection{Package pd.brett, pd.spieler}
\label{ssub:package_pd_brett}
\subparagraph{Beschreibung}
Die beiden Packages sind eng miteinander verbunden und stellen die Abstraktion des Bretts (welches die Felder enth√§lt), der Figuren und des Spielers in der Problem-Domain dar.

\subparagraph{Schnittstellen}
\begin{itemize}
	\item Der Einstiegspunkt ist das Spiel, da es das Brett, den Kartengeber und die Spieler enth√§lt.
\end{itemize}

\label{ssub:diagramme}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_brett}
	\caption{Klassendiagramm Brett und Figuren}
	\label{fig:pd_brett}
\end{figure}

\clearpage
\subsubsection{Package pd.serialisierung}

\subparagraph{Beschreibung}
Implementiert die abstrakten Klassen von dienste.serialisierung, um die Serialisierung von Klassen der Problem-Domain zu erm√∂glichen.

\subparagraph{Schnittstellen}
\begin{itemize}
	\item Bietet eine Basisklasse (BodesuriCodierbaresObjekt) f√ºr die Klassen der Problem-Domain an, die serialisiert werden k√∂nnen.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5 \textwidth]{kd_pd_serialisierung}
	\caption{Klassendiagramm Serialisierung in PD}
	\label{fig:kd_pd_serialisierung}
\end{figure}

\clearpage
\subsubsection{Package dienste.automat}
\label{ssub:package_dienste}
\subparagraph{Beschreibung}
Beinhaltet einen Zustandsautomaten der im Client und im Server f√ºr eine gezielte Abarbeitung des Spielablaufs sorgt. Der Automat wechselt aufgrund externer Events auf vorher definierten Bahnen zwischen den Zust√§nden hin und her. 

Der Automat bietet zwei Betriebsmodi an:
\begin{itemize}
	\item Eigenst√§ndiger automatischer Betrieb in einem dedizierte Thread. Der Automat liest neue Ereiggnise aus einer Synched Queue und verarbeitet diese. Sind keine Ereignisse anstehend blockiert der Automat
	\item Ferngesteuerter integrierter Betrieb. Der Automat wird vom Caller bei anstehnenden Ereignissen  aufgerufen und verarbeitet dieser exkat ein Ereignis (inklusive den dazugeh√∂renden Zust√§nden) und √ºbergibt anschliessend die Kontrolle wieder dem Caller. Der Modus eignet sich speziell f√ºr Unterautomaten bei welchen man keinen zus√§tzlichen Thread und eine seperate Ereignisqueue einsetzen m√∂chte. Der Hauptautomat liest die Events ein und gibt sie direkt dem Unterautomaten weiter. 
\end{itemize}

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Der Automat muss von den dar√ºberliegenden Klassen abgeleitet und spezifisch implementiert werden.
\end{itemize}	

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_automat_klassendiagramm}
	\caption{Klassendiagramm Automat}
	\label{fig:dienste_serialisierung}
\end{figure}

\clearpage
\subsubsection{Package dienste.serialisierung}

\subparagraph{Beschreibung}
Dieses Package ist f√ºr die Serialisierung und Deserialisierung der Java-Objekte zust√§ndig, welche anschliessend √ºber das Netzwerk versendet werden. 

\subparagraph{Schnittstellen}
\begin{itemize}
	\item Die abstrakte Klasse CodierbaresObjekt muss vom Benutzer dieses Packages implementiert werden. Dabei m√ºssen die Methoden \texttt{getCodierer} und \texttt{getCodiertesObjekt} √ºberschrieben werden. \texttt{getCodiertesObjekt} sollte ein neues konkretes CodiertesObjekt (z.\,B. BodesuriCodiertesObjekt) erstellen.
	\item Die zweite abstrakte Klasse CodiertesObjekt muss auch implementiert werden. Es muss nur \texttt{getCodierer} √ºberschrieben werden, um den gleichen Codierer zur√ºckzugeben wie bei CodierbaresObjekt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_dienste_serialisierung}
	\caption{Klassendiagramm Serialisierung in Dienste}
	\label{fig:kd_dienste_serialisierung}
\end{figure}

\clearpage
\subsubsection{Package dienste.netzwerk}
\label{ssub:package_dienste_netzwerk}
\subparagraph{Beschreibung}
Dieses Package kapselt die Socket-Schnittstelle von Java und bietet Dienste f√ºr die Netzwerkkommunikation an.

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item dienste.netzwerk verwendet die Klassen Event und EventQueue f√ºr die Kommunikation mit den dar√ºberliegenden Schichten.
% FIXME: Reto stimmt so n√ºmm (Reto)
	\item Die Kommunikation mit dem Netzwerk findet √ºber die Bibliotheken java.net statt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{dienste_netzwerk_client}
	\caption{Klassendiagramm Client in Netzwerk}
	\label{fig:dienste_netzwerk_client}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{dienste_netzwerk_server}
	\caption{Klassendiagramm Server in Netzwerk}
	\label{fig:dienste_netzwerk_server}
\end{figure}

\clearpage
\subsubsection{Package ui}
\label{ssub:package_ui}
Die UI-Schicht ist f√ºr die graphische Darstellung verantwortlich. Sie kommuniziert mit der Applikationsschicht top-down √ºber direkte Assoziationen und bottom-up √ºber Observer.

\begin{description}
  \item[ui.geteiltes] Klassen, die in verschiedenen Views verwendet werden.
	\item[ui.lobby] Ist f√ºr die Darstellung der Lobby verantwortlich.
	\item[ui.ressourcen] Es beinhaltet die Ressourcen, die f√ºr das Optische ben√∂tigt werden.
	\item[ui.spiel] Wird verwendet um die Views des Spieles zusammenzuf√ºhren.
	\item[ui.spiel.brett] K√ºmmert sich um die Darstellung des Brettes.
	\item[ui.spiel.steuerung] Dient als Steuerung der Karten und Sonderfunktionen.
	\item[ui.verbinden] Dienst zur Erstellung der Verbindung mit dem Server.
\end{description}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{ui_alle}
	\caption{Klassendiagramm UI}
	\label{fig:ui_alle}
\end{figure}

\clearpage
\subsubsection{Package ui.geteiltes}
\label{ssub:package_ui_geteiltes}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Dieses Package enth‰lt KLassen, die in verschiedenen Views verwendet werden. Sie dienen als Vereinheitlichung des Spielverhaltens.

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item BLabel dient zur Positionierung der Labels zentriert auf einen Koordinatenpunkt.
	\item ClickMouseAdapter ist ein MouseAdapter, der das gleiche Klickverhalten wie ein JButton hat.
\end{itemize}

\clearpage
\subsubsection{Package ui.spiel}
\label{ssub:package_ui_spiel}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Die Views des eigentlichen Spiels befinden sich in diesem Package. Sie sorgen f¸r die Darstellung des Spielbrettes, sowie auch der Steuerung der Spielkarten und der Sonderfunktionen.

\begin{itemize}
	\item Das Package brett k¸mmert sich um die Darstellung des Spielbrettes, auf dem sich die Figuren, Felder und Spielernamen befinden.
	\item Das Package steuerung dient zum Ziehen der Karten und "`Tauschen"' der Spielkarten mit dem Partner oder das "`Aufgeben"' in einer Runde.
\end{itemize}

\clearpage
\subsubsection{Package ui.verbinden}
\label{ssub:package_ui_verbinden}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Es regelt das kontrollierte Verbinden des Spielers zu einem angegebenen Server.

\begin{itemize}
	\item Die Aktion Abbrechen k¸mmert sich um das Schliessen des Frames.
	\item Die Aktion Beenden k¸mmert sich um das kontrollierte Beenden aller Threads.
	\item Die Aktion Verbinden k¸mmert sich umd das Verbinden zum Server.
\end{itemize}

\clearpage
\subsubsection{Package applikation}
\label{ssub:package_applikation}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Die Applikationsschicht ist f√ºr die Zustandssynchronisation (Spielst√§nde usw.) verantwortlich.

\subsubsection{Package applikation.zugentgegennahme}
\label{ssub:package_applikation_zugentgegennahme}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Die Zugentgegennahme sorgt f√ºr die Verbindung vom UI zur Problem-Domain. Durch das Klicken (ziehen der Figur) im UI werden Z√ºge an die Problem-Domain weitergeleitet und die Validierung eingeleitet.

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Bietet die Methode \texttt{ziehen} an, welche die Zugentgegennahme in einen neuen Status versetzt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{applikation_zugentgegennahme}
	\caption{Klassendiagramm Zugentgegennahme}
	\label{fig:applikation_zugentgegennahme}
\end{figure}

\clearpage
\subsubsection{Package applikation.client}
\label{ssub:package_applikation_client}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Der Zustandsautomat des Clients und dessen Zust√§nde. Sorgt f√ºr den korrekten Ablauf des Spiels auf der Client-Seite. Verarbeitet die eintretenden Events von GUI und Netzwerk und l√∂st entsprechende Aktionen aus.

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Bietet verschiedenste Instanzvariablen f√ºr das GUI und die zum Server geh√∂renden Zust√§nde an.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_applikation_client}
	\caption{Klassendiagramm Client in Applikation}
	\label{fig:kd_applikation_client}
\end{figure}

\clearpage
\subsubsection{Package applikation.server}
\label{ssub:package_applikation_server}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Der Zustandsautomat des Servers und dessen Zust√§nde. Sorgt f√ºr den korrekten Ablauf des Spiels auf der Server-Seite. Verarbeitet die eintretenden Events vom Netzwerk und l√∂st entsprechende Aktionen aus, um den Spielablauf zu steuern.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_applikation_server}
	\caption{Klassendiagramm Server in Applikation}
	\label{fig:kd_applikation_server}
\end{figure}

\clearpage
\subsubsection{Package applikation.events}
\label{ssub:package_applikation_events}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Dieses Package beinhaltet die Events, die eintreten k√∂nnen und um deren Behandlung sich der Automat k√ºmmert.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_applikation_events}
	\caption{Klassendiagramm Events}
	\label{fig:kd_applikation_events}
\end{figure}

\subsubsection{Package applikation.nachrichten}
\label{ssub:package_applikation_nachrichten}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Dieses Package beinhaltet alle m√∂glichen Nachrichtentypen, die zur Kommunikation zwischen Client und Server verwendet werden.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_applikation_nachricht}
	\caption{Klassendiagramm Nachrichten}
	\label{fig:kd_applikation_nachricht}
\end{figure}
\clearpage

\subsection{Prozesse \& Threads}
\label{sub:prozesse_threads}

Ein regul√§res Bodesuri-Spiel besteht aus f√ºnf eigenst√§ndigen Komponenten. Dies sind die vier Clients und der zentrale Server. Zwischen den Clients und dem Server besteht je ein TCP Socket. 

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{prozesse_und_threads}
	\caption{Prozesse \& Threads}
	\label{fig:prozesse_und_threads}
\end{figure}

\clearpage
\subsubsection{Client-Threads}
\label{ssub:client_threads}

\paragraph{Main-Thread}
\label{ssub:main_thread}

Der Main-Thread des Clients ist f√ºr die geordnete Koordination zwischen dem Spieler (via GUI) und den anderen Clients (via Server) zust√§ndig.


\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & BodesuriClient \\
\textbf{Anzahl}       & 1 \\
\textbf{Gestartet}    & Bei Prozessbeginn \\
\textbf{Beendet}      & Bei Programmende
\end{tabular}

\paragraph{Empf√§nger-Thread}
\label{ssub:empf√§nger_thread}

Der Empf√§nger-Thread ist f√ºr den Empfang von Netzwerk-Nachrichten zust√§ndig. Er liest aus einem java.net.Socket und speichert die eingegangenen Nachrichten √ºber das Briefkasten-Interface in der EventQueue.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & Empfaenger \\
\textbf{Anzahl}       & 1 \\
\textbf{Gestartet}    & Bei Verbindungsaufbau durch den Main-Thread (Klasse Endpunkt) \\
\textbf{Beendet}      & Bei Verbindungsabbau durch den Main-Thread (Klasse Endpunkt) oder bei Fehlern selbstt√§ndig.
\end{tabular}


\paragraph{Swing-Threads}
\label{ssub:swing_threads}

Swing startet intern verschiedene Threads. Die genauen Abl√§ufe und Struktur dieser Threads sind f√ºr diese Dokumentation nicht relevant.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & AWK-AppKit \\
\textbf{Anzahl}       & 1..* \\
\textbf{Gestartet}    & Durch Swing \\
\textbf{Beendet}      & N/A
% TODO: Reto: Abkl√§ren da gibts doch sicher ne methode oder so (reto)

\end{tabular}

\clearpage
\subsubsection{Server Threads}
\label{ssub:server}

Der Server ist f√ºr die Koordination der einzelnen Clients zust√§ndig.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & BodesuriServer \\
\textbf{Anzahl}       & 1 \\
\textbf{Gestartet}    & bei Prozessbeginn \\
\textbf{Beendet}      & Bei Spielende oder bei schweren Fehlern
\end{tabular}

\paragraph{Daemon}
\label{ssub:daemon}

Der Daemon ist ein Teil des Servers. Er nimmt eingehende Verbindungen entgegen und meldet diese √ºber das BriefkastenInterface (via EventQueue) an den Nutzer des Servers.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & Daemon \\
\textbf{Anzahl}       & 1 \\
\textbf{Gestartet}    & Durch den Main-Thread (Klasse Server) gestartet \\
\textbf{Beendet}      & Bei Programmende
\end{tabular}

\paragraph{Empf√§nger-Thread}
\label{ssub:empf√§nger_thread}

Der Empf√§nger-Thread ist f√ºr den Empfang von Netzwerk-Nachrichten zust√§ndig. Er liest aus einem java.net.Socket und speichert die eingegangenen Nachrichten √ºber das Briefkasten-Interface in der EventQueue.

Es wird pro offene Verbindung ein Empf√§nger gestartet.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & Empf√§nger \\
\textbf{Anzahl}       & 1..4 \\
\textbf{Gestartet}    & Durch den Daemon bei eingehenden Verbindungen  \\
\textbf{Beendet}      & Bei Verbindungsabbau durch den Main-Thread
\end{tabular}

\clearpage
\section{Spielablauf \& -zust√§nde}
\label{spielzustaende_nachrichten}
\subsection{Zust√§nde Client}
\label{sub:zust√§nde_client}
Abbildung~\vref{fig:zd_applikation_bodesuriclient} zeigt den Ablauf der Zust√§nde des Clients. Zust√§nde in gr√ºn sind passive Zust√§nde.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{zd_applikation_bodesuriclient}
	\caption{Zustandsdiagramm Client}
	\label{fig:zd_applikation_bodesuriclient}
\end{figure}

\subsubsection{ProgrammStart}
\label{ssub:programmstart}
Zustand in welchem der Automat beim Start ist. √ñffnet den VerbindenView und geht direkt in den Zustand VerbindungErfassen √ºber.


\subsubsection{VerbindungErfassen}
\label{ssub:verbinungerfassen}
Zustand wenn der Spieler die Verbindungsdaten eingeben muss. Wenn ein VerbindeEvent eintrifft, wird der Zustand Lobby aufgerufen.

\subsubsection{Lobby}
\label{ssub:lobby}
Zustand wenn der Spieler in der Lobby ist.
\begin{itemize}
	\item Wenn eine SpielStartNachricht eintrifft, wird der Zustand SpielStart aufgerufen.
	\item Wenn eine BeitrittsInformation eintrifft, wird werden die Informationen √ºber die beigetretenen Spieler aktualisiert. Der Zustand wird nicht gewechselt.
	\item Wenn eine BeitrittVerweigertNachricht eintrifft, wird das Spiel beendet.
\end{itemize}

\subsubsection{SpielStart}
\label{ssub:spielstart}
Zustand in welchem das Spiel (BodesuriView) gestartet wird. Geht direkt in NichtAmZug √ºber.

\subsubsection{NichtAmZug}
\label{ssub:nichtamzug}
Zustand wenn der Spieler nicht am Zug ist.
\begin{itemize}
	\item 	Wenn eine ZugAufforderung eintrifft, wird der Zustand AmZug aufgerufen.
	\item 	Wenn eine AktuellerSpielerInformation eintrifft, wird der aktuelle Spieler dargestellt, der Zustand aber nicht gewechselt.
	\item 	Wenn eine ZugEingabe eintrifft, wird Zug aus der Eingabe visualisiert. Der Zustand wird nicht gewechselt.
	\item 	Wenn eine RundenStart-Nachricht eintrifft, werden die erhaltenen Karten gespeichert und der Zustand StarteRunde aufgerufen.
	\item 	Wenn eine AufgabeInformation eintrifft, wird der Spieler, welcher aufgegeben hat, im UI angepasst. Der Zustand wird nicht gewechselt.
	\item 	Wenn eine SpielFertigNachricht eintrifft, wird der Gewinner angezeigt und SpielEnde aufgerufen.
\end{itemize}

\subsubsection{StarteRunde}
\label{ssub:starterunde}
Zustand wenn eine neue Runde gestartet wird. Alle Eigenschaften der Spieler werden zur√ºckgesetzt. Der Automat geht nach KarteTauschenAuswaehlen √ºber.

\subsubsection{KarteTauschenAuswaehlen}
\label{ssub:kartetauschenauswaehlen}
Zustand in dem wir warten bis der Spieler die Karte, die er tauschen m√∂chte, ausgew√§hlt hat. Tritt KarteGewaehltEvent ein, gehen wir in den Zustand KarteTauschenBekommen √ºber.

\subsubsection{KarteTauschenBekommen}
\label{ssub:kartetauschenbekommen}
Zustand wenn wir auf die Karte, die wir von unserem Mitspieler erhalten, warten. Wenn sie eintrifft, wird der Zustand NichtAmZug aufgerufen.

\subsubsection{AmZug}
\label{ssub:amzug}
Zustand in welchem der Spieler am Zug ist. Erstellt einen ZugAutomaten, der sich um das Erfassen und Validieren eines Zuges k√ºmmert. Eintreffende Events werden direkt an den ZugAutomaten weitergeleitet. Dieser sendet einen ZugErfasstEvent wenn er fertig ist. Der Event wird versandt und der Automat geht nach NichtAmZug √ºber.

\subsubsection{SpielEnde}
\label{ssub:spielende}
Zustand in welchem sich dem Automat befindet wenn wir das Spiel beenden wollen. In diesem Zustand werden Events, die m√∂glicherweise noch in der Queue warten, konsumiert, das UI heruntergefahren, die Verbindung zum Server geschlossen und der Automat beendet.

\subsection{Zust√§nde ZugAutomat}
\label{sub:zust√§nde_zugautomat}
Die Erfassung eines Zuges wurde aus dem Client-Automaten ausgelagert. Abbildung~\vref{fig:zd_applikation_bodesuriserver} zeigt den Ablauf der Zust√§nde des ZugAutomaten. Zust√§nde in gr√ºn sind passive Zust√§nde.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{zd_applikation_zugautomat}
	\caption{Zustandsdiagramm ZugAutomat}
	\label{fig:zd_applikation_zugautomat}
\end{figure}

\subsubsection{KarteWaehlen}
\label{ssub:kartewaehlen}
Zustand wenn der Spieler eine Karte ausw√§hlen muss. Wenn der KarteGewaehltEvent eintritt, wird der Zustand StartWaehlen aufgerufen.

\subsubsection{StartWaehlen}
\label{ssub:startwaehlen}
Zustand wenn der Spieler das Startfeld w√§hlen muss.
\begin{itemize}
	\item Trifft ein FeldGewaehltEvent ein, wird das Feld √ºberpr√ºft. Ergibt die Wahl Sinn, wird nach ZielWaehlen gewechselt. Sonst bleiben wir in diesem Zustand.
	\item Trifft ein KarteGewaehltEvent ein (der Spieler hat eine andere Karte ausgew√§hlt) wird nach KarteWaehlen gewechselt.
	\item Trifft ein FeldAbgewaehltEvent ein, wird das Brett zur√ºckgesetzt. Wir bleiben aber in diesem Zustand.
\end{itemize}

\subsubsection{ZielWaehlen}
\label{ssub:zielwaehlen}
Zustand wenn der Spieler das Zielfeld w√§hlen muss.
\begin{itemize}
	\item Trifft ein FeldGewaehltEvent ein, wird das Feld √ºberpr√ºft. Ergibt die Wahl Sinn, wird nach ZugValidieren gewechselt. Wurde das Startfeld ausgew√§hlt, wird das Startfeld wieder deaktiviert und nach StartWaehlen gewechselt.
	\item Trifft ein KarteGewaehltEvent ein (der Spieler hat eine andere Karte ausgew√§hlt), wird nach KarteWaehlen gewechselt.
	\item Trifft ein FeldAbgewaehltEvent ein, wird das Brett zur√ºckgesetzt. Wir bleiben aber in diesem Zustand.
	\item HoverStartEvent und HoverEndeEvent aktiveren bzw. deaktivieren das Hervorheben des Weges.
\end{itemize}

\subsubsection{ZugValidieren}
\label{ssub:zugvalidieren}
Validiert den erfassten Zug.
\begin{itemize}
	\item Ist die Karte eine Sieben und es wurden noch keine 7 Felder gefahren, wechseln wir zur√ºck nach StartWaehlen um eine weitere Bewegung zu erfassen.
	\item Ist der Zug ung√ºltig, wird eine Fehlermeldung gezeigt und zur√ºck nach ZielWaehlen gewechselt.
	\item Ist der Zug g√ºltig, wird er zur√ºck an den ClientAutomat √ºbermittelt und nach ZugautomatAbschluss gewechselt.
\end{itemize}

\subsubsection{ZugautomatAbschluss}
\label{ssub:zugautomatabschluss}
R√§umt den Zugautomaten auf. Alle Bewegungen werden zur√ºckgesetzt, die Kartenauswahl deaktiviert, die SteuerungsButtons ausgeblendet und in ZugautomatEndZustand √ºbergegangen.

\subsubsection{ZugautomatEndZustand}
\label{ssub:zugautomatendzustand}
Endzustand des Zugautomaten. Ignoriert alle eingehenden Events.


\subsection{Zust√§nde Server}
\label{sub:zust√§nde_server}

Abbildung~\vref{fig:zd_applikation_bodesuriserver} zeigt den Ablauf der Zust√§nde des Servers.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{zd_applikation_bodesuriserver}
	\caption{Zustandsdiagramm Server}
	\label{fig:zd_applikation_bodesuriserver}
\end{figure}

\subsubsection{ServerStart}
\label{ssub:serverStart}
Server wird gestartet. Der TCP-Daemon wird initialisiert und es werden die notwenigen Vorbereitungen getroffen um Spieler zu akzeptieren.

\subsubsection{EmpfangeSpieler}
\label{ssub:empfangespieler}
Neue Spieler k√∂nnen mittels der Nachricht SpielBeitreten dem Spiel beitreten. Dem beigetretenen Spieler wird mit der Nachricht BeitrittBest√§tigung der Beitritt best√§tigt.

Sobald alle Spieler komplett sind, wird in den Zustand StarteSpiel gewechselt.

\subsubsection{StarteSpiel}
\label{ssub:startespiel}
Den Spielern wird der Spielstart mit der Nachricht SpielStart angek√ºndet. Die Partnerschaften werden, wie auf Abbildung~\vref{fig:dienste_partner} gezeigt, zwischen den Spielern ausgehandelt.\footnote{Wurde nicht implementiert.}

\subsubsection{StartRunde}
\label{ssub:startrunde}
Eine neue Runde wird gestartet und mit der Nachricht RundenStart den Spielern mitgeteilt. Es werden allen Spielern Karten ausgeteilt.

\subsubsection{KartenTauschen}
\label{ssub:kartentauschen}
Alle Spieler m√ºssen mit ihrem Partner eine Karte tauschen. Der Server wartet bis alle Spieler die zu tauschende Karte mit der Nachricht KartenTausch gemeldet haben. Anschliessend wird die getauschte Karte mit derselben Nachricht dem Partner gemeldet.

\subsubsection{StarteZug}
\label{ssub:startezug}
Ein Zug wird gestartet. Der Server bestimmt welcher Spieler an der Reihe ist und teilt ihm dies mit der Nachricht Zugaufforderung mit. 

\subsubsection{WarteAufZug}
\label{ssub:warteaufzug}
Der Server wartet, bis der Spieler seinen Zug erfasst hat. Sobald dieser mitgeteilt wurde, wechselt der Server in den Zustand VersendeZug.

\subsubsection{SendeZug}
\label{ssub:sendezug}
Der erfasste Zug wird auf Richtigkeit gepr√ºft und anschliessend allen Spielern mitgeteilt.

\subsubsection{ZugAbschluss}
\label{ssub:zugabschluss}
Server schliesst den Zug formell ab. Es wird gepr√ºft, ob das Spiel beziehungsweise die Runde abgeschlossen ist und in den Zustand SpielEnde respektive RundenStart gewechselt. Ist weder das Spiel noch die Runde fertig wird in den Zustand StartZug gewechselt.

\subsubsection{Spielende}
\label{ssub:spielende}
Das Ende des Spieles wird mittels der Nachricht SpielEnde den Spielern mitgeteilt.

\clearpage
\subsection{Nachrichten \& Events}
\label{sub:nachrichten_und_events}


\subsubsection{Events}
\label{ssub:events}

\begin{itemize}
	\item VerbindeEvent
	\item KarteGewaehltEvent
	\item BewegungEingegebenEvent
\end{itemize}

\subsubsection{Nachrichten}
\label{ssub:nachrichten}

\begin{itemize}
	\item SpielBeitreten
	\item BeitrittsBestaetigung
	\item SpielStartNachricht
	\item SpielVollNachricht
	\item ZugAuffoderung
	\item ZugInformation
	\item ChatNachricht
	\item RundenStart
	\item KartenTausch
	\item SpielEnde
\end{itemize}

\clearpage
\section{Dynamische Abl√§ufe}
\label{dynamische_ablauefe}
\subsection{Nachrichtenfluss durch die Schichten}
\label{sub:nachrichtenfluss_durch_die_schichten}
Die Abbildungen~\vref{fig:sd_verbindung_erstellen_client} und~\vref{fig:sd_verbindung_erstellen_server} zeigen den Schnitt durch die Architektur von Bodesuri. Sie zeigen die Aufrufe durch die Architekturschichten beim Erstellen einer neuen Verbindung auf der Seite des Clients und des Servers.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{sd_verbindung_erstellen_client}
	\caption{Sequenzdiagramm Verbindung erstellen -- Client}
	\label{fig:sd_verbindung_erstellen_client}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{sd_verbindung_erstellen_server}
	\caption{Sequenzdiagramm Verbindung erstellen -- Server}
	\label{fig:sd_verbindung_erstellen_server}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{sd_verbindung_erstellen_endpunkt}
	\caption{Sequenzdiagramm Verbindung erstellen -- EndPunkt}
	\label{fig:sd_verbindung_erstellen_endpunkt}
\end{figure}

\subsection{Rundenstart}
\label{sub:rundenstart}
Die Abbildung~\vref{fig:dienste_rundenstart} zeigt den Ablauf beim Start einer neuen Runde.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7 \textwidth]{dienste_rundenstart}
	\caption{Sequenzdiagramm Rundenstart}
	\label{fig:dienste_rundenstart}
\end{figure}

\clearpage
\subsection{Validierung von Spielz√ºgen}
\label{ssub:validierung_von_spielz√ºgen}
Abbildung~\vref{fig:pd_validierung} zeigt die Validierung der Spielz√ºge.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_validierung}
	\caption{Sequenzdiagramm Validierung von Spielz√ºgen}
	\label{fig:pd_validierung}
\end{figure}

\clearpage
\subsection{Serialiserung}
\label{sub:serialiserung}
Abbildung~\vref{fig:dienste_serialisierung} zeigt den Ablauf bei der Serialisierung von Objekten, damit sie √ºber das Netzwerk √ºbertragen werden k√∂nnen.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_serialisierung}
	\caption{Sequenzdiagramm Serialisierung}
	\label{fig:dienste_serialisierung}
\end{figure}

\clearpage

\subsection[Partnerschaften bilden]{Partnerschaften bilden\footnote{Wurde nicht implementiert.}}
\label{sub:partnerschaften_bilden}

Abbildung~\vref{fig:dienste_partner} zeigt die m√∂glichen Zust√§nde beim Finden eines Partners.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_partner}
	\caption{Zustandsdiagramm Partnerschaften bilden}
	\label{fig:dienste_partner}
\end{figure}

Die Abildung~\vref{fig:dienste_partnerschaft_normal} zeigt Ablauf des Bildens von Partnerschaften.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_partnerschaft_normal}
	\caption{Sequenzdiagramm Partnerschaften bilden}
	\label{fig:dienste_partnerschaft_normal}
\end{figure}

\clearpage
\subsection{Chat}
\label{sub:nachrichtenaustausch_zwischen_client_und_server}
Abbildung~\vref{fig:dienste_chat} zeigt den Verlauf des Austausches von Nachrichten zwischen den Clients und dem Server am Beispiel einer Chat-Nachricht.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_chat}
	\caption{Sequenzdiagramm Chat}
	\label{fig:dienste_chat}
\end{figure}

\clearpage
\section{Externes Design}
\label{externes_design}

\subsection{Verbinden}

Beim Starten des Spiels wird der Spieler aufgefordert, die Serverdaten zur Verbindung und seinen Spielernamen einzugeben.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7 \textwidth]{gui_verbindung}
	\caption{Design Verbinden}
	\label{fig:gui_verbindung}
\end{figure}

\clearpage

\subsection{Lobby}
\label{externes_design_lobby}

In der Lobby k√∂nnen die Spieler einen Partner f√ºr das Spiel ausw√§hlen\footnote{Wurde nicht implementiert.}. Der ausgew√§hlte Partner muss die Anfrage akzeptieren, um die Gruppe zu bilden. Sobald der Spieler bereit ist, das Spiel zu beginnen, w√§hlt er im Spielstatus "<bereit"> aus. In der Zwischenzeit k√∂nnen sich die Spieler im Chat unterhalten.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{gui_lobby}
	\caption{Design Lobby}
	\label{fig:gui_lobby}
\end{figure}

\clearpage

\subsection{Spiel}
\label{externes_design_spielbrett}

Das Spiel besteht aus verschiedenen Views:
\begin{itemize}
	\item In der BrettView wird das Spielbrett mit den Feldern und Spielfiguren dargestellt.
	\item In der SpielerView werden die einzelnen Spieler mit Gruppenzugeh√∂rigkeit aufgelistet.
	\item Die KartenView beinhaltet die Karten des Spielers.
	\item In der ChatView k√∂nnen sich die Spieler unterhalten.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{gui_spiel}
	\caption{Design Spiel}
	\label{fig:gui_spiel}
\end{figure}

\clearpage
\section{Designentscheidungen}

\subsection{Zustandsautomat}
Unser Spiel hat einen komplexen Ablauf, sowohl auf der Client- als auch auf der Serverseite. Der gr√∂sste Teil der Abl√§ufe wird von Events im Userinterface oder von Netzwerk-Nachrichten ausgel√∂st. Darum haben wir uns entschlossen, den Spielablauf in einem Zustandsautomaten zu verpacken.

Damit ist es m√∂glich, den Programmablauf, der sonst in komplexem nacheinander aufzurufendem Programmcode verpackt w√§re, in verschiedene Klassen auszulagern und den \emph{Gap} zwischen dem Code und den in der Elaboration gezeichneten Zustandsdiagrammen klein zu halten.

\subsection{Synchronisation UI/Automat}

Bodesuri verwendet f√ºr die Ablaufsteuerung und die interne Zustandssynchronisation zwischen Client und Server Zustandsautomaten. Der Zustandsautomat des Clients ist zus√§tzlich noch f√ºr die saubere Einbindung der dar√ºber liegenden Schicht verantwortlich, zurzeit das GUI mit seinem Controller. Es stellte sich fr√ºh heraus, dass auch GUI und Automat gut synchronisiert werden m√ºssen, so muss z.\,B. die Kartenauswahl im GUI deaktiviert werden, sobald eine Karte gew√§hlt wurde. Wird dies nicht gemacht, kann der Automat bei Fehleingaben (der Benutzer w√§hlt eine weitere Karte obwohl bereits getauscht) Events erhalten, welche in einem anderen Zustand gar keinen Sinn mehr ergeben und zu einer Exception f√ºhren.

Die offensichtliche L√∂sung f√ºr das Problem w√§re eine kontrollierte Aktivierung und Deaktivierung aller GUI-Elemente in den betroffenen Zust√§nden, sprich das GUI in den Zustandsablauf einzubinden. Zum Beispiel k√∂nnte der Zustand Kartenwahl bei Zustandseintritt die Auswahl aktivieren und beim Verlassen des Zustands wieder deaktivieren. Eine solche L√∂sung ist aber leider auch mit Problemen verbunden. Das GUI und seine Komponenten laufen in eigenen Threads und k√∂nnen noch w√§hrend der Verarbeitung des Zustands weiter agieren. Zum Beispiel k√∂nnte sich der Automat in der Verarbeitung der Kartenwahl befinden w√§hrend das GUI, im Glauben es sei immer noch im gleichen Zustand, einen weiteren Kartenwahl-Event ausl√∂sen. Passiert dies, f√ºhrt es h√∂chstwahrscheinlich zu einem unerwarteten Event (Out-Of-State-Event) und somit zum kontrollierten, aber sinnlosen, Absturz.

Damit diese offensichtliche L√∂sung (zustandsbewusstes GUI) funktionieren k√∂nnte, m√ºsste die Event-Verarbeitung von GUI und Automaten irgendwie koordiniert werden.

Folgende Varianten standen zur Auswahl:

\begin{itemize}
	\item GUI-Elemente werden bereits im ActionHandler des GUIs deaktiviert
	\begin{itemize}
		\item \textbf{Vorteil:} Keine Race-Conditions m√∂glich
		\item \textbf{Nachteil:} Viel Zustandslogik im GUI, Erweiterungen sind aufw√§ndig ("<in welchen Handlers muss ich das noch deaktivieren">)
	\end{itemize}
	\item GUI blockiert bis Automat abgearbeitet wird / Synchrone Event-Verarbeitung
	\begin{itemize}
		\item \textbf{Vorteil:} Keine Race-Conditions m√∂glich, einfache Handhabung seitens GUI
		\item \textbf{Nachteil:} GUI k√∂nnte unter Umst√§nden tr√§ge wirken, komplizierte Umsetzung
	\end{itemize}
\end{itemize}

Ein ganz anderer Ansatz besteht darin, das GUI ganz von den Zust√§nden zu entkoppeln. Das GUI k√∂nnte jederzeit Events ausl√∂sen und es w√§re die Aufgabe des Zustandsautomaten zu erkennen, ob diese Events im gegebenen Zustand Sinn ergeben oder halt eben nicht. Nat√ºrlich k√∂nnten einzelne Bedienelemente trotzdem Zustandsabh√§ngig aktiviert \& deaktiviert werden (z.\,B. um die Benutzerfreundlichkeit zu erh√∂hen) aber die korrekte Funktion des Automaten w√§re davon unabh√§ngig, er k√∂nnte problemlos mit "<Out-Of-State-Events"> umgehen.

\textbf{Vorteile:}
\begin{itemize}
	\item GUI simpler, entkoppelt von Zust√§nden
	\item Keine komplizierte Synchronisation mit Swing
\end{itemize}

\textbf{Nachteile:}
\begin{itemize}
	\item Automat ist bei GUI-Events weniger strikt\footnote{Der Automat ist in allen anderen Bereichen sehr strikt, was eine fr√ºhe Fehlererkennung mit sich bringt. Zum Beispiel k√∂nnen bei Events zur Synchronisation mit dem Server keine \emph{Fehler} toleriert werden.}
\end{itemize}

Wir entschieden uns aufgrund der genannten Vorteile f√ºr die Implementierung der dritten Variante.

\subsection{Kommunikation GUI/Automat}

Im Laufe der Phase \emph{Construction 1} zeigten sich erste Schwierigkeiten mit der Implementierung des Controllers. Urspr√ºnglich war geplant, dass sich alle UI-Elemente, die direkt durch den Automaten kontrolliert werden m√ºssen, beim Controller registrieren. Der Controller h√§tte dann die Elemente, je nach Anweisung des Automaten, direkt manipulieren k√∂nnen. Leider hatte dies verschiedene Nachteile. Einerseits war mit diesem System das GUI und der Controller extrem eng verkn√ºpft. Dies zeigte sich in verschiedensten zyklischen Abh√§ngigkeiten. Andererseits war aber auch der Code teilweise schwer nachvollziehbar, weil pl√∂tzlich gewisse GUI-Logik in Mouse-Adaptern und √§hnlichen Klassen steckte. Zus√§tzlich wurde, da jede auch noch so kleine UI-relevante Zustands√§nderung gemeldet werden musste, der Controller immer komplizierter und war schwer zu durchschauen.

Wir analysierten die Situation und kamen nach einigen Diskussionen zum Schluss, dass ein alternatives Kommunikations-Modell die Kommunikation vereinfachen k√∂nnte. Zus√§tzlich setzten wir uns das Ziel, dass das GUI nichts mehr direkt √ºber den GUIController wissen muss. 

Das neue Modell sah vor, dass der grosse Teil der Kommunikation √ºber Observer passieren sollte. Also z.\,B. das Feld weiss von sich selber ob es zurzeit ausgew√§hlt ist und meldet etwaige Zustandswechsel √ºber Observer-Event an das GUI. Dieses neue Konzept stellte uns pl√∂tzlich vor ein weiteres Problem. Wir sahen, dass wir pl√∂tzlich ganz viele, f√ºr die PD nicht relevante, Informationen in der Problem-Domain h√§tten ablegen m√ºssen. Auf Grund der komplexen Regel-Logik war die Problem-Domain jedoch bereits relativ kompliziert. 

Um eine Vergr√∂sserung der Problem-Domain zu verhindern begannen wir, einige ihrer Teile in Form von \emph{Dekoratoren} in der Applikationsschicht abzubilden. Diese Dekoratoren bildeten mehr oder minder dieselbe Funktionalit√§t\footnote{Daf√ºr leiteten sie die Methodenaufrufe einfach direkt in die darunterliegende Schicht weiter.} ab und observierten die jeweils dekorierten Objekte in der Problem-Domain. Zus√§tzlich beinhalteten sie aber Felder und Logik, die nur f√ºr die Applikationschicht relevant sind, so zum Beispiel den aktuellen Selektierungszustand.

Mit diesem System wird das User-Interface √ºber alle √Ñnderungen informiert, sei es nun eine √Ñnderung am PD-Objekt oder am Dekorator in der Applikationsschicht. Sollte eine alternative GUI-Implementierung kein Interesse an diesen Events haben, kann es diese entweder ignorieren oder sich gar nicht erst als Observer registrieren.

Diese √Ñnderungen zog gr√∂ssere Arbeiten nach sich, aber unter dem Strich hat sie die Logik bedeutend einfacher gemacht. Es h√§tte jedoch einige doppelte Arbeit erspart werden k√∂nnen, wenn diese bessere L√∂sung fr√ºher erkannt worden w√§re.

\subsection{Multitier-Architektur des Servers}
Der Server wurde in mehrere Schichten und vertikal angeordnete Partitions aufgeteilt. Diese Hierarchie hat sich deshalb als erforderlich erwiesen, da sonst Abh√§ngigkeiten von tieferliegenden zu h√∂herliegenden Schichten entstehen w√ºrden.

\subsection{Applikationsschicht}
Die Applikationsschicht wurde eingef√ºhrt, weil es wegen der Netzwerkf√§higkeit viel Synchronisationsarbeit (z.\,B. f√ºr Zust√§nde) gibt. Sie hat folgende Hauptaufgaben:
	\begin{itemize}
		\item Zustandssynchronisation als erste Vorstufe der Netzwerkkommunikation. Spezifische Nachrichten werden eingepackt, an die darunterliegenden Schichten weitergeleitet, um dann √ºber das Netzwerk verteilt und empfangen zu werden.
		\item Controller-Komponente des MVC-Konzeptes, welche die Ereignisse im UI abf√§ngt und verarbeitet, sowie √Ñnderungen in der Problem-Domain an das UI weiterleitet.
	\end{itemize}

\subsection{Regelverstoss als Exception}

Wenn eine Zug get√§tigt werden soll, wird zuerst mit den Angaben des Benutzers eine ZugEingabe zusammengestellt. Diese wird dann vom Regelsystem auf G√ºltigkeit gepr√ºft (Methode \texttt{validieren}), wobei es zwei m√∂gliche Ergebnisse gibt:
\begin{itemize}
	\item Die ZugEingabe ist g√ºltig und das Resultat ist ein ausf√ºhrbarer Zug, der von der Regel zusammengestellt wurde.
	\item Die ZugEingabe ist ung√ºltig und das Resultat ist ein Verstoss mit einer Erkl√§rung, warum die ZugEingabe ung√ºltig ist.
\end{itemize}

Eine M√∂glichkeit, diese beiden Ergebnisse von einer Methode zur√ºckzugeben ist, eine Klasse zu machen, die beides beinhalten kann, oder eine Basisklasse mit zwei sehr unterschiedlichen Resultat-Unterklassen. Mit dieser Variante wird jedoch sowohl der Code der \texttt{validieren}-Methode als auch der aufrufende Code komplizierter als n√∂tig, da immer eine Fallunterscheidung gemacht werden muss. Wird zum Beispiel der Code von \texttt{validieren} in mehrere kleine Untermethoden zerlegt, muss bei jedem Aufruf der R√ºckgabewert gepr√ºft werden und je nachdem mit der Validierung weitergemacht oder aufgeh√∂rt werden.

Eine zweite Variante w√§re, das Ergebnis der letzten Validierung in einer st√§ndig vorhandenen Klasse zu speichern, wo es bei Bedarf abgerufen werden kann. Der Nachteil daran ist, dass das Ergebniss entkoppelt vom Aufruf von \texttt{validieren} an einem anderen Ort abgeholt werden muss, was nicht intuitiv ist und die beiden Klassen sehr stark voneinander Abh√§ngig macht.

Die dritte und schliesslich implementierte Variante ist, bei G√ºltigkeit einen Zug zur√ºckzugeben und andernfalls eine Exception des Typs \texttt{RegelVerstoss} zu werfen. Damit sind die Nachteile beider oben genannten Varianten beseitigt, die beiden verschiedenen Resultate sind sauber getrennt und aufrufender Code wird zudem noch gezwungen, den Fehlerfall zu behandeln (\texttt{RegelVerstoss} ist \emph{checked}).

\subsection{M√∂gliche Z√ºge in Regel}

Die folgenden beiden Methoden in \texttt{Regel} haben ganz √§hnliche Funktionen:

\begin{itemize}
	\item \texttt{istZugMoeglich} findet heraus, ob mit dieser Regel f√ºr den √ºbergebenen Spieler noch ein Zug m√∂glich ist.
	\item \texttt{getMoeglicheZuege} findet alle m√∂glichen ZugEingaben mit dieser Regel f√ºr den √ºbergebenen Spieler.
\end{itemize}

Wie werden diese implementiert? Es w√§re nat√ºrlich m√∂glich, \texttt{istZugMoeglich} anhand von \texttt{getMoeglicheZuege} zu definieren, indem geschaut wird, ob diese eine leere Liste zur√ºckgibt. Dies kann aber rechenintensiv sein, da in jedem Fall alle M√∂glichkeiten durchgegangen werden, obwohl das nicht n√∂tig ist.

Eine andere Variante w√§re, den Code einfach zu kopieren und jeweils einen kleinen Teil darin anzupassen, um den Anforderungen an die beiden Methoden gerecht zu werden. Dies h√§tte aber duplizierten Code zur Folge und eine erschwerte Anpassbarkeit, da jeweils in zwei Funktionen der gleiche Code angepasst werden m√ºsste.

% TODO: Wie heisst das Pattern, das √§hnlich ist?

Deshalb entschieden wir uns, die folgende Variante zu implementieren. Es wird eine interne (\emph{protected}) dritte Methode erstellt, die \texttt{liefereZugEingaben} heisst. Diese √ºbernimmt die gleichen Argumente wie die beiden obengenannten Methoden und zus√§tzlich noch ein Objekt des neuen Typs \texttt{ZugEingabeAbnehmer}. Die Methode liefert dem Abnehmer √ºber \texttt{nehmeEntgegen} eine Zugeingabe und stellt anhand des R√ºckgabewertes fest, ob mit der Suche abgebrochen werden soll.

Die Methode \texttt{istZugMoeglich} ruft \texttt{liefereZugEingaben} mit einem Abnehmer auf, der nur auf die erste Zugeingabe wartet, einen Wert setzt, und signalisiert, dass abgebrochen werden kann. Danach wird der Wert ausgelesen und je nachdem zur√ºckgegeben, ob ein Zug m√∂glich ist oder nicht.

F√ºr \texttt{getMoeglicheZuege} wird ein Abnehmer verwendet, der alle Zugeingaben speichert und immer zur√ºckgibt, dass er weitere w√ºnscht.

Mit dieser L√∂sung ist der Code zur Findung von Zugeingaben nur einmal vorhanden und die beiden Methoden laufen trotzdem nur so lange wie n√∂tig.

\clearpage
\section{Eingetretene Risiken}
\label{eingetretene_risiken}

\subsection{RMI}
\label{sub:rmi}

Im Verlauf der ersten Tests mit RMI stellte sich schnell heraus, dass RMI weit mehr kann als f√ºr das Projekt notwendig w√§re und es dem Projekt somit unn√∂tig Komplexit√§t hinzuf√ºgt. Andererseits stellt RMI  einige Anforderungen an die Client/Server-Struktur, die sich nur schwer mit den Projektanforderungen decken lassen. So kann RMI nur erschwert hinter Firewalls betrieben werden und eine Kommunikation √ºber ein durch NAT\footnote{Network Adress Translation. Firewall-Feature welches Netzbereiche auf andere Netzbereiche abbildet. Wird h√§ufig verwendet, um private Adressbereiche im Internet hinter einer einzelnen Adresse zu verstecken.} verstecktes Netzwerk ist gar nicht erst m√∂glich. Da die Internet-Zugangsl√∂sungen in den meisten Haushalten auf Firewalls und NAT basieren, k√∂nnte das Spiel von einem gr√∂sseren Teil der potenziellen Kundschaft gar nicht gespielt werden.

Wir entschieden uns aufgrund dieser Probleme, auf eine eigene L√∂sung umzusteigen, welche auf den Java-Klassen Socket und Object(Input|Output)Stream basiert. Insgesamt gingen etwa 10 Stunden Arbeit f√ºr diese Umstellung verloren.

\subsection{Java 2D}
\label{java_2d}

Nachdem das CLI (Command Line Interface) erstellt war, entwarfen wir ein GUI daf√ºr, das die Felder und Figuren darstellen sollte. Mit Java 2D ist das Zeichnen sehr einfach, da man die Koordinaten der zu zeichnenden Elemente angeben kann. Doch mussten wir leider feststellen, dass das Ansprechen eines Objektes etwas komplizierter ist. So muss zum Beispiel bei einem Mausklick das geklickte Objekt √ºber die Koordinaten ermittelt werden. Ausserdem muss man sich um das Aktualisieren der Anzeige bei Ver√§nderungen selber k√ºmmern.

In einem zweiten Versuch erstellten wir das selbe Spielbrett mit Swing und wir kamen zum Schluss, dass dies die einfachere Methode ist. Die Objekte k√∂nnen mit einem speziellen Layout auch auf Koordinaten genau platziert werden und Klicke darauf kann man wie gewohnt mit einem MouseListener abfangen. Als Objekt kann man zum Beispiel ein Label mit einem Icon verwenden. Dies reicht f√ºr ein Brettspiel vollkommen aus.

Aus diesen Gr√ºnden haben wir uns dazu entschlossen, f√ºr das GUI als einzige Technologie Swing einzusetzen. Insgesamt gingen 7.5 Stunden Arbeit f√ºr diese Umstellung verloren.

\clearpage
\section{Besser als erwartet}

Einige Dinge, von denen wir dachten, sie w√ºrden viel Zeit brauchen, waren einfacher zu implementieren als erwartet.

\subsection{Serialisierung}

Um Objekte √ºber das Netzwerk zu schicken, m√ºssen sie serialisiert werden, das heisst den Zustand eines Objektes so in eine bin√§re Form zu bringen, dass es an einem anderen Ort oder zu einem anderen Zeitpunkt eingelesen werden kann, um wieder den urspr√ºngliche Zustand des Objektes zu erhalten.

Normalerweise ist das Objekt an einem Ort vorhanden und am anderen nicht. In unserem Fall m√ºssen aber alle Objekte der Problem-Domain sowohl auf jedem Client als auch auf dem Server bereits existieren. Wenn nun ein Objekt √ºbertragen wird, wird am empfangenden Ort ein neues Objekt erstellt, das zwar die gleichen Daten hat, aber nicht die gleiche Identit√§t (gleiche Speicheradresse) wie das bereits vorhandene Objekt. Wenn dann mit dem empfangenen Objekt etwas gemacht wird, wird das z.\,B. vom GUI, welches das bereits vorhandene Objekt observiert, nicht bemerkt.

F√ºr diese Problemstellung wird also ein Mechanismus gebraucht, der bei der Deserialisierung nicht neue Objekte, sondern die bereits vorhandenen zur√ºckliefert. Dies ist bei der Java-Serialisierung mit den beiden Methoden \texttt{writeReplace} (beim zu schreibenden Objekt) und \texttt{readResolve} (beim einzulesenden Objekt) m√∂glich, wo jeweils Objekte zur√ºckgegeben werden k√∂nnen, die dann anstelle der urspr√ºnglichen verwendet werden.

Damit ist die Grundlage f√ºr eine Serialisierung wie wir sie brauchen vorhanden. Darauf aufbauend ist nun noch eine eindeutige Codierung der Objekte n√∂tig, die auf jedem Rechner gleich sein muss. Der Ablauf einer √úbertragung eines Objektes ist dann wie folgt:

\begin{enumerate}
	\item Beim zu schreibenden Objekt (zum Beispiel \texttt{Feld}) wird in \texttt{writeReplace} ein \texttt{CodiertesObjekt} zur√ºckgeliefert, welches nur einen Code enth√§lt, der dieses Objekt eindeutig identifiziert (zum Beispiel \texttt{Feld 47}).
	\item Das stellvertretende Objekt wird √ºber das Netzwerk geschickt.
	\item Beim Einlesen von \texttt{CodiertesObjekt} wird von Java die Methode \texttt{readResolve} aufgerufen, welche in einer Tabelle zum Code das dazugeh√∂rige Objekt nachschaut und zur√ºckgibt.
\end{enumerate}

Dank der Serialisierungsschnittstelle von Java ist diese L√∂sung transparent. Der Vorgang ist in Abbildung~\vref{fig:dienste_serialisierung} detailliert als Sequenzdiagramm dargestellt.


\clearpage
\listoffigures

\end{document}
